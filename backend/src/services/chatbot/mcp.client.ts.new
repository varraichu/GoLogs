import {
  spawn,
  ChildProcess
} from "child_process";
import {
  Client
} from "@modelcontextprotocol/sdk/client/index.js";
import {
  StdioClientTransport
} from "@modelcontextprotocol/sdk/client/stdio.js";
import {
  GoogleGenerativeAI
} from "@google/generative-ai";
import readline from "readline/promises";
import dotenv from "dotenv";

dotenv.config();
import fs from "fs";
import path from "path";
import { ObjectId } from "mongodb";
import mongoose from "mongoose";
import UserGroup from "./models/UserGroup";
import { connectToDatabase } from "./startup/db";

import Application from "./models/Application";
import User from "./models/User";
const userid = "68650fd57a72d0b64525da71"
const is_admin = false; // Hardcoded for now

function loadSchemaDescriptions(): string {
  const modelsDir = path.join(process.cwd(), "src", "models");
  const files = fs.readdirSync(modelsDir);

  let schemaSummary = "Database Collections and Schemas:\n";

  for (const file of files) {
    const content = fs.readFileSync(path.join(modelsDir, file), "utf-8");
    schemaSummary += \n### ${file}\n${content}\n;
  }

  return schemaSummary;
}

// --- UPDATED HELPER FUNCTION TO CLEANSE SCHEMA ---
function cleanSchema(schema: any): any {
  if (typeof schema !== 'object' || schema === null) {
    return schema;
  }

  if (Array.isArray(schema)) {
    return schema.map(cleanSchema);
  }

  const newSchema: any = {};
  for (const key in schema) {
    // Add 'const' to the list of skipped properties
    if (key === '$schema' || key === 'additionalProperties' || key === 'const') {
      continue; // Skip these properties
    }
    newSchema[key] = cleanSchema(schema[key]); // Recursively clean nested objects/arrays
  }
  return newSchema;
}
const getAssignedApplicationsForUser = async (userId: string) => {
  if (!mongoose.Types.ObjectId.isValid(userId)) {
    throw new Error("Invalid userId");
  }

  // Find user groups where the user is a member
  let userGroups = await UserGroup.find({ members: userId }).lean();
  userGroups = userGroups.filter((g) => g.is_active === true);

  if (!userGroups.length) return [];

  // Collect all assigned application IDs
  const groupAppIds = userGroups.flatMap((g) =>
    g.assigned_applications.map((id) => id.toString())
  );

  // Fetch application details
  const apps = await Application.find({
    _id: { $in: groupAppIds.map((id) => new ObjectId(id)) },
  }).lean();

  return apps.map((a) => ({
    id: a._id.toString(),
    name: a.name,
  }));
};



const GEMINI_API_KEY = process.env.GEMINI_API_KEY!;
if (!GEMINI_API_KEY) throw new Error("GEMINI_API_KEY is not set");

const MONGO_URI = process.env.MONGO_URI;
if (!MONGO_URI) throw new Error("MONGO_URI is not set");

let mcpProc: ChildProcess | null = null;

async function launchMcpServer() {
  mcpProc = spawn("npx", ["-y", "mongodb-mcp-server", "--connectionString", MONGO_URI!], {
    stdio: ["pipe", "pipe", "inherit"],
  });
  mcpProc.on("error", (err) => console.error("MCP server failed:", err));
  console.log("âœ… MCP server started.");
}

class MCPChatClient {
  private mcp: Client;
  private llm: GoogleGenerativeAI;
  private tools: any[] = [];

  constructor() {
    this.llm = new GoogleGenerativeAI(GEMINI_API_KEY);
    this.mcp = new Client({
      name: "mongodb-mcp-client",
      version: "1.0.0"
    });
  }

  async connect() {
    const transport = new StdioClientTransport({
      command: "npx",
      args: ["-y", "mongodb-mcp-server", "--connectionString", MONGO_URI!],
    });

    await this.mcp.connect(transport);
    console.log("âœ… Connected to MCP server");

    const toolsResult = await this.mcp.listTools();

    this.tools = [{
      functionDeclarations: toolsResult.tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: cleanSchema(tool.inputSchema), 
      })),
    }, ];

    console.log("ðŸ”§ Available tools:", toolsResult.tools.map((t) => t.name).join(", "));
  }
 

  async processQuery(query: string) {
    const schemaInfo = loadSchemaDescriptions();
    const assignedApps = await getAssignedApplicationsForUser(userid);

    // Prepare list for LLM prompt
    const assignedAppsText = assignedApps.length
          ? assignedApps.map(a => - ${a.name} (id: ${a.id})).join("\n")
          : "None";
    
    const initialPrompt = `
      You are an AI assistant that can query MongoDB using the following collections (with names logs, applications) and schemas in the test database:

      ${schemaInfo}

      **The current user is ${is_admin ? "an admin" : "NOT an admin"}**.
      - If NOT an admin, they can ONLY read from the \logs\ collection (using find/aggregate). They CANNOT insert, update, or delete any data.

      **Assigned Applications for this user:**
      ${assignedAppsText}

      âš ï¸ If the user asks for logs of an application that is NOT in the assigned list (or just a similar name), TELL them that this application is not assigned to them and DO NOT call any tools.

      When calling tools:
      - Use correct collection names & fields according to the schema given to you. Once an operation is complete, provide a final response to the user without calling more tools. If you try an operation and are unable to do it, respond to the user that you can't do it and stop making tool calls.
      - Use MongoDB ObjectId syntax: "application_id":{"$oid":""} 
      
      Further instructions (IMPORTANT): 
        -If the request requires multiple tool calls, make one tool call after the next until the operation is completed. 
        - Display final results in a readable form, not raw JSON. Show the application name rather than id in the response if needed. 
      User query: ${query}
    `;
    //console.log("Initial prompt:", initialPrompt);
    const messages: any[] = [{
      role: "user",
      parts: [{
        text: initialPrompt
      }]
    }, ];

    const finalText: string[] = [];

    const model = this.llm.getGenerativeModel({
      model: "gemini-2.5-flash",
      tools: this.tools,
    });


    let response = await model.generateContent({
      contents: messages,
    });

    while (true) {
      if (!response.response.candidates || response.response.candidates.length === 0) {
        console.warn("No candidates found in the Gemini API response. Breaking loop.");
        break;
      }

      const candidate = response.response.candidates[0];
      if (!candidate.content) {
        console.warn("Candidate content is undefined. Breaking loop.");
        break;
      }
      const parts = candidate.content.parts;

      let messageContent = "";
      let toolCalls: any[] = [];

      for (const part of parts) {
        if (part.text) {
          messageContent += part.text;
        }
        if (part.functionCall) {
          toolCalls.push({
            function: part.functionCall
          });
        }
      }

      if (messageContent) {
        finalText.push(messageContent);
        messages.push({
          role: "model",
          parts: [{
            text: messageContent
          }]
        });
      }

      if (toolCalls.length > 0) {
        messages.push({
          role: "model",
          parts: toolCalls.map(tc => ({
            functionCall: tc.function
          }))
        });

        for (const toolCall of toolCalls) {
          const toolName = toolCall.function.name;
          const toolArgs = toolCall.function.args || {};
          console.log(âš™ï¸ Calling MCP tool: ${toolName} with args ${JSON.stringify(toolArgs)});
          if (!is_admin) {
            if (toolName.includes("insert") || toolName.includes("update") || toolName.includes("delete")) {
              console.warn(Blocked tool call ${toolName} (user is not admin));
              finalText.push("âŒ You are not allowed to modify data.");
              continue; }

            if(toolArgs.collection !== "logs"){
              console.warn(Blocked tool call ${toolName} (user is not admin));
              finalText.push("âŒ You are not allowed to access any collection other than logs.");
              continue;
            }
          
          if ((toolName.includes("find") || toolName.includes("aggregate"))) {
              // Restrict logs to assigned apps only
              const assignedAppIds = assignedApps.map((a) => ({ $oid: a.id }));

              if (!toolArgs.filter) toolArgs.filter = {};

              if (toolArgs.filter.application_id) {
                toolArgs.filter.$and = [
                  { application_id: toolArgs.filter.application_id },
                  { application_id: { $in: assignedAppIds } },
                ];
                delete toolArgs.filter.application_id;
              } else {
                toolArgs.filter.application_id = { $in: assignedAppIds };
              }
            console.log(âš™ï¸ After filtering Calling MCP tool: ${toolName} with args ${JSON.stringify(toolArgs)});
          } }

          let result;
          try {
            result = await this.mcp.callTool({
              name: toolName,
              arguments: toolArgs,
            });
          } catch (error: any) {
            console.error(Error calling tool ${toolName}:, error);
            result = {
              error: Failed to call tool ${toolName}: ${(error as Error).message}
            };
          }

          messages.push({
            role: "tool",
            parts: [{
              functionResponse: {
                name: toolName,
                response: result
              }
            }],
          });

          finalText.push([Tool ${toolName} result]: ${JSON.stringify(result)});
        }

        response = await model.generateContent({
          contents: messages,
        });
        continue;
      }

      break;
    }

    return finalText.join("\n");
  }

  async chatLoop() {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    console.log("\nðŸ’¬ Chat started! Type your query or 'quit' to exit.");

    while (true) {
      const msg = await rl.question("\nQuery: ");
      if (msg.toLowerCase() === "quit") break;
      const response = await this.processQuery(msg);
      console.log("\nðŸ“ Response:\n" + response);
    }

    rl.close();
  }
}

(async () => {
  await connectToDatabase();

  await launchMcpServer();

  const client = new MCPChatClient();
  await client.connect();
  await client.chatLoop();

  // if (mcpProc) mcpProc.kill();
})();